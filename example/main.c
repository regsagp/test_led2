/**
  *****************************************************************************
  * @title   main.c
  * @author  lordzuqi
  * @date    28 Jun 2014
  * @brief   Blinking LED with Input from Button
  *******************************************************************************
  */
////// The above comment is automatically generated by CoIDE ///////////////////

#include <stm32f4xx_gpio.h>
#include <stm32f4xx_rcc.h>

//#include <stm32f4xx.h>
//#include <stm32f4xx_gpio.h>
//#include <stm32f4xx_rcc.h>
#define LED1 GPIOD, GPIO_Pin_12
#define LED2 GPIOD, GPIO_Pin_13
#define LED3 GPIOD, GPIO_Pin_14
#define LED4 GPIOD, GPIO_Pin_15
#define button GPIOA, GPIO_Pin_0
int a, b, c, d ;
GPIO_InitTypeDef GPIO_InitStruct;

static void GPIO_setup(void)
{
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_15 | GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_12; // we want to configure all LED GPIO pins
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT; 		// we want the pins to be an output
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; 	// this sets the GPIO modules clock speed
	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP; 	// this sets the pin type to push / pull (as opposed to open drain)
	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL; 	// this sets the pullup / pulldown resistors to be inactive
	GPIO_Init(GPIOD, &GPIO_InitStruct);
}

static void button_setup(void)
{
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;		  // we want to configure PA0
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN; 	  // we want it to be an input
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;//this sets the GPIO modules clock speed
	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;   // this sets the pin type to push / pull (as opposed to open drain)
	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_DOWN;   // this enables the pulldown resistor --> we want to detect a high level
	GPIO_Init(GPIOA, &GPIO_InitStruct);
}

// Обработчик прерывания TIM6_DAC
void TIM6_DAC_IRQHandler(void)
{
	TIM6->SR &= ~TIM_SR_UIF; //Сбрасываем флаг UIF
	GPIOC->ODR ^= (GPIO_Pin_9 | GPIO_Pin_8); //Инвертируем состояние светодиодов
}

static void startTimer(int msec)
{
	TIM6->DIER |= TIM_DIER_UIE; //разрешаем прерывание от таймера
	TIM6->CR1 |= TIM_CR1_CEN; // Начать отсчёт!
	TIM6->ARR = msec; // Чтоб прерывание случалось раз в секунду
}

static void initTimer()
{
	GPIO_InitTypeDef PORT;
	//Включаем порт С и таймер 6
	RCC_APB1PeriphClockCmd(RCC_AHB1Periph_GPIOC , ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE);
	// Настроим ноги со светодиодами на выход
	PORT.GPIO_Pin = (GPIO_Pin_9 | GPIO_Pin_8);
	PORT.GPIO_Mode = GPIO_Mode_OUT;
	PORT.GPIO_OType = GPIO_OType_PP; 	// this sets the pin type to push / pull (as opposed to open drain)
	PORT.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_Init(GPIOC, &PORT);
	TIM6->PSC = 24000 - 1; // Настраиваем делитель что таймер тикал 1000 раз в секунду
	NVIC_EnableIRQ(TIM6_DAC_IRQn); //Разрешение TIM6_DAC_IRQn прерывания
}

int pressure_to_delay_data[] = {
	// num of rows	// power
	2, 				5,		10, 			// 1st row is power

	//	pressure, delay for power
    0, 				0,		0,
    100, 			1000,	2000,
    200, 			500,	700
};

int get_delay()
{
    int pressure = 150;
    int power = 7;

    int power_cols =  pressure_to_delay_data[0];
    int total_cols = power_cols + 1;

    int n_pressure = sizeof(pressure_to_delay_data) / (total_cols * sizeof(*pressure_to_delay_data)) - 1; // skip 1st power row
    if (n_pressure < 2)
        return 0;

    int power_col1 = 1, power_col2 = 2;

    int i = 1;
    for(; i < power_cols; i++)
    {
    	int pow = pressure_to_delay_data[i];
    	if(power > pow)
    		continue;

    	power_col1 = i - 1;
    	power_col2 = i;
    	break;
    }

    if (pressure <= pressure_to_delay_data[0])
        return pressure_to_delay_data[1];

    int * pressure_to_delay_data_it = pressure_to_delay_data + total_cols;
    int p1 = pressure_to_delay_data[total_cols], p2 = pressure_to_delay_data[total_cols + 1];

    i = 1;
    for (; i < n_pressure; i++, pressure_to_delay_data_it+=total_cols)
    {

        p2 = pressure_to_delay_data_it[0];
        if (pressure > p2)
            continue;

        p1 = pressure_to_delay_data[(i - total_cols) + 0];
        if (p2 == p1)
            continue;
    }

    int v11 = pressure_to_delay_data_it[power_col1];
    int v21 = pressure_to_delay_data_it[power_col1];

    int v12 = pressure_to_delay_data_it[power_col2];
    int v22 = pressure_to_delay_data_it[power_col2];

    int v1 = v11 + (v21 - v11) * (pressure - p1) / (p2 - p1);
    int v2 = v12 + (v22 - v12) * (pressure - p1) / (p2 - p1);

    int pow1 = pressure_to_delay_data[power_col1];
    int pow2 = pressure_to_delay_data[power_col2];
    return v1 + (v2 - v1) * (power - pow1) / (pow2 - pow1);
}

void init_adc()
{
}

int main(void)
{
	GPIO_setup();
	button_setup();
	GPIO_ResetBits(GPIOD, GPIO_Pin_12 | GPIO_Pin_13 |GPIO_Pin_14 |GPIO_Pin_15 );

	initTimer();

	startTimer(1000);

	while(1)
	{

	}
}

#if 0
#include <stm32f4xx_gpio.h>
#include <stm32f4xx_rcc.h>

GPIO_InitTypeDef  GPIO_InitStructure;

void Delay(__IO uint32_t nCount);

int main(void)
{

	SystemInit();

	/* GPIOD Periph clock enable */
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

	/* Configure PD12, PD13, PD14 and PD15 in output pushpull mode */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure);

    while(1)
    {

    	 /* PD12 to be toggled */
    	    GPIO_SetBits(GPIOD, GPIO_Pin_12);

    	    /* Insert delay */
    	    Delay(0x3FFFFF);

    	    /* PD13 to be toggled */
    	    GPIO_SetBits(GPIOD, GPIO_Pin_13);

    	    /* Insert delay */
    	    Delay(0x3FFFFF);

    	    /* PD14 to be toggled */
    	    GPIO_SetBits(GPIOD, GPIO_Pin_14);

    	    /* Insert delay */
    	    Delay(0x3FFFFF);

    	    /* PD15 to be toggled */
    	    GPIO_SetBits(GPIOD, GPIO_Pin_15);

    	    /* Insert delay */
    	    Delay(0x7FFFFF);

    	    GPIO_ResetBits(GPIOD, GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15);

    	    /* Insert delay */
    	    Delay(0xFFFFFF);
    	  }


}

void Delay(__IO uint32_t nCount)
{
  while(nCount--)
  {
  }
}
#endif
