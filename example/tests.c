/**
  *****************************************************************************
  * @title   main.c
  * @author  lordzuqi
  * @date    28 Jun 2014
  * @brief   Blinking LED with Input from Button
  *******************************************************************************
  */
////// The above comment is automatically generated by CoIDE ///////////////////

#include <stm32f4xx.h>
#include "defines.h"
#include "tm_stm32f4_delay.h"
#include "tm_stm32f4_hd44780.h"

#include <stm32f4xx_gpio.h>
#include <stm32f4xx_rcc.h>
#include "defines.h"

#define LED1 GPIOD, GPIO_Pin_12
#define LED2 GPIOD, GPIO_Pin_13
#define LED3 GPIOD, GPIO_Pin_14
#define LED4 GPIOD, GPIO_Pin_15
#define button GPIOA, GPIO_Pin_0
int a, b, c, d ;

GPIO_InitTypeDef GPIO_InitStruct;
GPIOSpeed_TypeDef speed = GPIO_Speed_25MHz;


#include "ports.h"

void set_port(PortType port, int id)
{
    GPIO_SetBits(port, id); // sw2
}
void reset_port(PortType port, int id)
{
    GPIO_ResetBits(port, id); // sw2
}
int get_port(PortType port, int id)
{
    uint8_t c = GPIO_ReadInputDataBit(port, id);
    return c;
}

static void button_setup(void)
{
#ifdef DISCOVERY
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;		  // we want to configure PA0
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN; 	  // we want it to be an input
    GPIO_InitStruct.GPIO_Speed = speed;//this sets the GPIO modules clock speed
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;   // this sets the pin type to push / pull (as opposed to open drain)
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_DOWN;   // this enables the pulldown resistor --> we want to detect a high level
    GPIO_Init(GPIOA, &GPIO_InitStruct);
#else

    // left, right, del, right buttons
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    GPIO_InitStruct.GPIO_Pin = /*GPIO_Pin_9 | GPIO_Pin_10 |*/ GPIO_Pin_13 | GPIO_Pin_14;		  // we want to configure PA0
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN; 	  // we want it to be an input
    GPIO_InitStruct.GPIO_Speed = speed;//this sets the GPIO modules clock speed
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;   // this sets the pin type to push / pull (as opposed to open drain)
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
    GPIO_Init(GPIOC, &GPIO_InitStruct);

    // shot in (PA5)
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;		  // we want to configure PA0
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN; 	  // we want it to be an input
    GPIO_InitStruct.GPIO_Speed = speed;//this sets the GPIO modules clock speed
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;   // this sets the pin type to push / pull (as opposed to open drain)
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_DOWN;   // this enables the pulldown resistor --> we want to detect a high level
    GPIO_Init(GPIOA, &GPIO_InitStruct);

#endif
}

void GPIO_setup(void)
{

#ifdef DISCOVERY
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_15 | GPIO_Pin_14 | GPIO_Pin_13 | GPIO_Pin_12; // we want to configure all LED GPIO pins
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT; 		// we want the pins to be an output
    GPIO_InitStruct.GPIO_Speed = speed; 	// this sets the GPIO modules clock speed
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP; 	// this sets the pin type to push / pull (as opposed to open drain)
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL; 	// this sets the pullup / pulldown resistors to be inactive
    GPIO_Init(GPIOD, &GPIO_InitStruct);
#else
    // switch 2, switch 1 for test
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT; 		// we want the pins to be an output
    GPIO_InitStruct.GPIO_Speed = speed; 	// this sets the GPIO modules clock speed
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP; 	// this sets the pin type to push / pull (as opposed to open drain)
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL; 	// this sets the pullup / pulldown resistors to be inactive
    GPIO_Init(GPIOA, &GPIO_InitStruct);

	// shotout (PC5)
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5; // we want to configure all LED GPIO pins
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT; 		// we want the pins to be an output
    GPIO_InitStruct.GPIO_Speed = speed; 	// this sets the GPIO modules clock speed
	GPIO_InitStruct.GPIO_OType = GPIO_OType_PP; 	// this sets the pin type to push / pull (as opposed to open drain)
	GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL; 	// this sets the pullup / pulldown resistors to be inactive
	GPIO_Init(GPIOC, &GPIO_InitStruct);
#endif

    button_setup();
}


void test_buttons()
{
	GPIO_setup();

	GPIO_ResetBits(GPIOA, GPIO_Pin_4); // sw2
	GPIO_ResetBits(GPIOC, GPIO_Pin_5); // shotout

	while(1) {
		uint8_t c = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_3);
		if(c)
		{
			GPIO_SetBits(GPIOA, GPIO_Pin_4); // sw2
			lcd_print("test", 0);
		}
		else
			GPIO_ResetBits(GPIOA, GPIO_Pin_4); // sw2

		uint8_t c2 = GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);
		if(c2)
			GPIO_SetBits(GPIOC, GPIO_Pin_5); // shotout
		else
			GPIO_ResetBits(GPIOC, GPIO_Pin_5); // shotout

	}
}


// Обработчик прерывания TIM6_DAC
void TIM6_DAC_IRQHandler(void)
{
	TIM6->SR &= ~TIM_SR_UIF; //Сбрасываем флаг UIF
	GPIOC->ODR ^= (GPIO_Pin_9 | GPIO_Pin_8); //Инвертируем состояние светодиодов
}

static void startTimer(int msec)
{
	TIM6->DIER |= TIM_DIER_UIE; //разрешаем прерывание от таймера
	TIM6->CR1 |= TIM_CR1_CEN; // Начать отсчёт!
	TIM6->ARR = msec; // Чтоб прерывание случалось раз в секунду
}

static void initTimer()
{
	GPIO_InitTypeDef PORT;
	//Включаем порт С и таймер 6
	RCC_APB1PeriphClockCmd(RCC_AHB1Periph_GPIOC , ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE);
	// Настроим ноги со светодиодами на выход
	PORT.GPIO_Pin = (GPIO_Pin_9 | GPIO_Pin_8);
	PORT.GPIO_Mode = GPIO_Mode_OUT;
	PORT.GPIO_OType = GPIO_OType_PP; 	// this sets the pin type to push / pull (as opposed to open drain)
	PORT.GPIO_Speed = GPIO_Speed_2MHz;
	GPIO_Init(GPIOC, &PORT);
	TIM6->PSC = 24000 - 1; // Настраиваем делитель что таймер тикал 1000 раз в секунду
	NVIC_EnableIRQ(TIM6_DAC_IRQn); //Разрешение TIM6_DAC_IRQn прерывания
}

void init_lcd_mt()
{
	MT_Init();
	    MT_Delay(1000);

	    MT_FunctionSet8bit();
	    MT_Delay(1000);

	    MT_FunctionSet4bit(1, 1);
	    MT_Delay(1000);

	    MT_FunctionSet4bit(1, 1);
	    MT_Delay(1000);

	    MT_DisplayOnOff();
	    MT_Delay(1000);

	    MT_DisplayClear();
	    MT_Delay(10000);
}

#if 00000000
#include "tm_stm32f4_delay.h"
#include "tm_stm32f4_adc.h"
//#include "tm_stm32f4_usart.h"
#include <stdio.h>
void test_adc()
{
	 char str[150];
	/* Initialize Delay library */
	    TM_DELAY_Init();

	    /* Initialize USART1, 115200 baud, TX: PB6 */
	    //TM_USART_Init(USART1, TM_USART_PinsPack_2, 115200);


	    /* Initialize ADC1 on channel 0, this is pin PA0 */
	    //TM_ADC_Init(ADC1, ADC_Channel_0);

	    /* Initialize ADC1 on channel 3, this is pin PA3 */
	    //TM_ADC_Init(ADC1, ADC_Channel_3);

	    /* Initialize ADC1 */
	    TM_ADC_InitADC(ADC1);

	    /* Enable vbat channel */
	    TM_ADC_EnableVbat();


	    while (1) {
	        /* Read & format data */
	        sprintf(str, "----------------------------\nVbat voltage: %d mV\n", TM_ADC_ReadVbat(ADC1));

	        printf("----------------------------\nVbat voltage: %d mV\n", TM_ADC_ReadVbat(ADC1));

	        /* Put to USART */
	        //TM_USART_Puts(USART1, str);

	        /* Little delay */
	        Delayms(1000);
	    }
}

#endif // adc

int test_usb(void);


void delay(int ms)
{
	Delayms(ms);
	//MT_Delay(ms);
	}

int main3(void)
{
	//test_lcd();
	//return 0;
	//test_adc();

	/* Initialize system */
	//SystemInit();

	//TM_RCC_InitSystem();
	//HAL_Init();
	TM_DELAY_Init();

	//GPIO_setup();

	int i = 0;

#ifdef DISCOVERY
//    GPIO_SetBits(GPIOD, GPIO_Pin_12); //Подаем «1» на PD12
	//main2();	//return 0;
    //GPIO_SetBits(GPIOD, GPIO_Pin_13); //Подаем «1» на PD12

	while(1)
	{
	//Если кнопка нажата, то…
	    if (GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==1)
	    {
	    	char sz[32];
	    	sprintf(sz, "%d", i);
	    	lcd_print(sz, 0);
	    	//delay(1000);

	    	int tm = 500;
	        GPIO_SetBits(GPIOD, GPIO_Pin_12); //Подаем «1» на PD12
	        delay(tm); //Функция задержки
	        GPIO_SetBits(GPIOD, GPIO_Pin_13); //Подаем «1» на PD13
	        delay(tm);
	        GPIO_SetBits(GPIOD, GPIO_Pin_14); //Подаем «1» на PD14
	        delay(tm);
	        //GPIO_SetBits(GPIOD, GPIO_Pin_15); //Подаем «1» на PD15
	        delay(tm);
	        GPIO_ResetBits(GPIOD, GPIO_Pin_12|GPIO_Pin_13|GPIO_Pin_14/*|GPIO_Pin_15*/); //Сбрасываем все пины в «0»
	        delay(tm);
	    }
        //delay(1000); // ~3sec
        delay(100); // ~.3sec

        if(i % 2 == 0)
        	GPIO_SetBits(GPIOD, GPIO_Pin_15); //Подаем «1» на PD15
        else
        	GPIO_ResetBits(GPIOD, GPIO_Pin_15); //Подаем «1» на PD15

        i++;

	}

	return 0;

#endif

	//Если кнопка нажата, то…

	/*
	GPIO_setup();
	button_setup();
	GPIO_ResetBits(GPIOD, GPIO_Pin_12 | GPIO_Pin_13 |GPIO_Pin_14 |GPIO_Pin_15 );

	initTimer();

	startTimer(1000);

	while(1)
	{

	}
	*/
	set_port(GPIOA,GPIO_Pin_5); // shotin
	set_port(GPIOC, GPIO_Pin_5); // shotout
	set_port(GPIOA, GPIO_Pin_3); // switch 1

	reset_port(GPIOC, GPIO_Pin_13); // left
	reset_port(GPIOC, GPIO_Pin_14); // right
	reset_port(GPIOA, GPIO_Pin_4); // switch 2

	while(1)
	{
	    if (get_port(GPIOC,GPIO_Pin_13)==1) // left
	    {
	    	lcd_print("left", 0);
	    	set_port(GPIOA,GPIO_Pin_3); // sw1
	    }
	    else
	    	reset_port(GPIOA,GPIO_Pin_3);

	    if (get_port(GPIOC,GPIO_Pin_14)==1) // right
	    {
	    	set_port(GPIOA, GPIO_Pin_4); // switch 2
	    	lcd_print("right", 0);

	    }
	    else
	    	reset_port(GPIOA, GPIO_Pin_4);

        if(i % 2 == 0)
        	set_port(GPIOC, GPIO_Pin_5); // shotout
        else
        	reset_port(GPIOC, GPIO_Pin_5);

	    Delayms(3);
        i++;

	}
	return 0;
}

//#endif
